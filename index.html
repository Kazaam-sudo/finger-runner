alert("FINGER RUNNER v6 LOADED");

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>Finger Runner</title>

    <link rel="manifest" href="manifest.json" />
    <meta name="theme-color" content="#0b0b0b" />

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        background: #0b0b0b;
        overflow: hidden;
        touch-action: none;
        font-family: system-ui, sans-serif;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="game"></canvas>

    <script>
      /* ========= VERSION MARKER ========= */
      console.log("FINGER RUNNER v6 â€” MENU + POLISH");

      /* ================= CANVAS ================= */
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      function resize() {
        canvas.width = innerWidth;
        canvas.height = innerHeight;
      }
      resize();
      addEventListener("resize", resize);

      /* ================= STATE ================= */
      let screen = "MENU"; // MENU | GAME
      let running = false;

      /* ================= CONSTANTS ================= */
      const R = 14;
      const SAFE_GAP = R * 4;
      const BLOCK_H = 26;

      /* ================= STORAGE ================= */
      let bestScore = +localStorage.getItem("bestScore") || 0;

      /* ================= GAME DATA ================= */
      let score = 0;
      let speed = 2;
      let patternIndex = 0;
      let spawnDist = 0;

      const player = { x: canvas.width / 2, y: canvas.height - 120, r: R };
      let target = { x: player.x, y: player.y };

      let obstacles = [];
      let gates = [];

      /* ================= SHAKE ================= */
      let shake = 0;
      function addShake(power = 8) {
        shake = power;
      }
      function applyShake() {
        if (shake > 0) {
          ctx.translate(
            (Math.random() - 0.5) * shake,
            (Math.random() - 0.5) * shake
          );
          shake *= 0.85;
        }
      }

      /* ================= INPUT ================= */
      function handleStart(x, y) {
        if (screen === "MENU") {
          screen = "GAME";
          resetGame();
          running = true;
        } else if (screen === "GAME") {
          running = true;
          target.x = x;
          target.y = y;
        }
      }
      function handleMove(x, y) {
        if (screen === "GAME" && running) {
          target.x = x;
          target.y = y;
        }
      }

      canvas.addEventListener("touchstart", (e) => {
        const t = e.touches[0];
        handleStart(t.clientX, t.clientY);
      });
      canvas.addEventListener("touchmove", (e) => {
        const t = e.touches[0];
        handleMove(t.clientX, t.clientY);
      });
      canvas.addEventListener("mousedown", (e) =>
        handleStart(e.clientX, e.clientY)
      );
      canvas.addEventListener("mousemove", (e) =>
        handleMove(e.clientX, e.clientY)
      );

      /* ================= GATES ================= */
      function spawnGate() {
        let gapX;
        const t = patternIndex % 3;
        if (t === 0) gapX = canvas.width / 2 - SAFE_GAP / 2;
        if (t === 1)
          gapX = (patternIndex % 2 ? 0.7 : 0.3) * canvas.width - SAFE_GAP / 2;
        if (t === 2)
          gapX =
            (Math.sin(patternIndex * 0.8) * 0.4 + 0.5) * canvas.width -
            SAFE_GAP / 2;

        gapX = Math.max(20, Math.min(canvas.width - SAFE_GAP - 20, gapX));

        const gate = { y: -BLOCK_H, scored: false };
        gates.push(gate);

        obstacles.push(
          { x: 0, y: gate.y, w: gapX, h: BLOCK_H, gate },
          {
            x: gapX + SAFE_GAP,
            y: gate.y,
            w: canvas.width - (gapX + SAFE_GAP),
            h: BLOCK_H,
            gate,
          }
        );

        patternIndex++;
      }

      /* ================= COLLISION ================= */
      function hit(o) {
        return (
          player.x + player.r > o.x &&
          player.x - player.r < o.x + o.w &&
          player.y + player.r > o.y &&
          player.y - player.r < o.y + o.h
        );
      }

      /* ================= LOOP ================= */
      function loop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        applyShake();

        if (screen === "MENU") {
          drawMenu();
        } else {
          updateGame();
          drawGame();
        }

        ctx.restore();
        requestAnimationFrame(loop);
      }

      function updateGame() {
        if (!running) return;

        player.x += (target.x - player.x) * 0.22;
        player.y += (target.y - player.y) * 0.22;

        spawnDist += speed;
        if (spawnDist > 120) {
          spawnGate();
          spawnDist = 0;
        }

        gates.forEach((g) => {
          g.y += speed;
          if (!g.scored && g.y > player.y) {
            g.scored = true;
            score++;
          }
        });

        obstacles.forEach((o) => (o.y = o.gate.y));
        obstacles = obstacles.filter((o) => o.y < canvas.height + 40);
        gates = gates.filter((g) => g.y < canvas.height + 40);

        for (const o of obstacles) {
          if (hit(o)) {
            addShake();
            endGame();
            break;
          }
        }

        speed += 0.0008;
      }

      function endGame() {
        running = false;
        bestScore = Math.max(bestScore, score);
        localStorage.setItem("bestScore", bestScore);
        screen = "MENU";
      }

      /* ================= RESET ================= */
      function resetGame() {
        score = 0;
        speed = 2;
        patternIndex = 0;
        spawnDist = 0;
        obstacles = [];
        gates = [];
        player.x = canvas.width / 2;
        player.y = canvas.height - 120;
        target.x = player.x;
        target.y = player.y;
      }

      /* ================= DRAW ================= */
      function drawBackground() {
        const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
        g.addColorStop(0, "#0e0e0e");
        g.addColorStop(1, "#000");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      function drawGame() {
        drawBackground();

        ctx.shadowColor = "#00ff88";
        ctx.shadowBlur = 12;
        ctx.fillStyle = "#00ff88";
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.fillStyle = "#ff5555";
        obstacles.forEach((o) => ctx.fillRect(o.x, o.y, o.w, o.h));

        ctx.fillStyle = "#fff";
        ctx.font = "14px monospace";
        ctx.fillText(`Score: ${score}`, 20, 28);
      }

      function drawMenu() {
        drawBackground();

        ctx.fillStyle = "#00ff88";
        ctx.font = "28px sans-serif";
        ctx.fillText(
          "Finger Runner",
          canvas.width / 2 - 110,
          canvas.height / 2 - 60
        );

        ctx.fillStyle = "#fff";
        ctx.font = "18px sans-serif";
        ctx.fillText("Tap to Play", canvas.width / 2 - 55, canvas.height / 2);

        ctx.font = "14px monospace";
        ctx.fillText(
          `Best: ${bestScore}`,
          canvas.width / 2 - 35,
          canvas.height / 2 + 40
        );
      }

      loop();

      /* ================= SERVICE WORKER ================= */
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker.register("sw.js");
      }
    </script>
  </body>
</html>
